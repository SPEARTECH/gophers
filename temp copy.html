	<!DOCTYPE html>
	<html>
		<head>
			<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
			<link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
			<script src="https://cdn.tailwindcss.com"></script>
			<script src="https://code.highcharts.com/highcharts.js"></script>
			<script src="https://code.highcharts.com/modules/boost.js"></script>
			<script src="https://code.highcharts.com/modules/exporting.js"></script>
			<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
			<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
		</head>
		<body>
			<div id="app" style="text-align: center;" class=" h-screen pt-12">
				<div id="datatable"></div>
			</div>
		</body>
		<script type="module">
            // Use Blob + anchor; fallback to window.open write.
            function openInNewTab() {
                try {
                    const htmlContent = document.documentElement.outerHTML;
                    const blob = new Blob([htmlContent], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.target = '_blank';
                    a.rel = 'noopener';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                } catch (e) {
                    const w = window.open('', '_blank');
                    if (!w) { alert('Popup blocked'); return; }
                    w.document.open();
                    w.document.write(document.documentElement.outerHTML);
                    w.document.close();
                }
            }
			const { createApp } = Vue
            import { Gophers } from 'https://cdn.jsdelivr.net/npm/gophers/gophers.js'
			createApp({
			delimiters : ['[[', ']]'],
				data(){
					return {
						data: [
                            { col1: 'A', col2: 3, col3: 'X' },
                            { col1: 'B', col2: 1, col3: 'Y' },
                            { col1: 'C', col2: 2, col3: 'Z' }
                        ],
						selected_col: {},
						pages: 0,
						page_list: [],
						current_page: 1,
						pageSize: 50
					}
				},
				methods: {
      recomputePagination() {
        this.pages = Math.max(1, Math.ceil(this.rowCount / this.pageSize));
        if (this.current_page > this.pages) this.current_page = this.pages;
        if (this.current_page < 1) this.current_page = 1;
        this.updatePageList();
      },
      updatePageList() {
        const p = this.pages;
        const cur = this.current_page;
        if (p <= 6) {
          this.page_list = Array.from({length: p}, (_, i) => i + 1);
          return;
        }
        // sliding window of up to 6 pages
        let start = Math.max(1, cur - 2);
        let end = Math.min(p, start + 5);
        start = Math.max(1, end - 5);
        this.page_list = Array.from({length: end - start + 1}, (_, i) => start + i);
      },
      first_page(){ this.current_page = 1; },
      prev_page(){ if (this.current_page > 1) this.current_page -= 1; },
      pagefunc(page){ this.current_page = page; },
      next_page(){ if (this.current_page < this.pages) this.current_page += 1; },
      last_page(){ this.current_page = this.pages; },
					
       exportCSV() {
        //  const cols = Array.isArray(this.cols) ? this.cols.slice() : [];
        //  if (!cols.length) return;
        //  // Determine the maximum row count across all columns
        //  let rowCount = 0;
        //  for (const c of cols) {
        //    const len = (this.data[c] || []).length;
        //    if (len > rowCount) rowCount = len;
        //  }
        //  const esc = (v) => {
        //    if (v === null || v === undefined) return '';
        //    if (typeof v === 'object') v = JSON.stringify(v);
        //    let s = String(v);
        //    s = s.replace(/"/g, '""');
        //    if (/[",\r\n]/.test(s)) s = '"' + s + '"';
        //    return s;
        //  };
        //  const lines = [];
        //  // Header row
        //  lines.push(cols.map(esc).join(','));
        //  // Data rows
        //  for (let i = 0; i < rowCount; i++) {
        //    const row = cols.map(c => esc((this.data[c] || [])[i]));
        //    lines.push(row.join(','));
        //  }
        //  const csv = lines.join('\\r\\n');
        //  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        //  const url = URL.createObjectURL(blob);
        //  const a = document.createElement('a');
        //  a.href = url;
        //  a.download = 'dataframe.csv';
        //  document.body.appendChild(a);
        //  a.click();
        //  document.body.removeChild(a);
        //  URL.revokeObjectURL(url);
        console.log(this.data);
        var df = ReadJSON(this.data)

        df.ToCSVFile('test_js_dataframe.csv');
        // df.toCSV().then((csv) => {
        //     const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        //     const url = URL.createObjectURL(blob);
        //     const a = document.createElement('a');
        //     a.href = url;
        //     a.download = 'dataframe.csv';
        //     document.body.appendChild(a);
        //     a.click();
        //     document.body.removeChild(a);
        //     URL.revokeObjectURL(url);
        // });
       },					
	   sortColumnAsc(col) {
						// Create an array of row indices
						const rowIndices = Array.from({ length: this.data[col].length }, (_, i) => i);

						// Sort the row indices based on the values in the specified column (ascending)
						rowIndices.sort((a, b) => {
							if (this.data[col][a] < this.data[col][b]) return -1;
							if (this.data[col][a] > this.data[col][b]) return 1;
							return 0;
						});

						// Reorder all columns based on the sorted row indices
						for (const key in this.data) {
							this.data[key] = rowIndices.map(i => this.data[key][i]);
						}

						// Update the selected column
						this.selected_col = col;
					},
					sortColumnDesc(col) {
						// Create an array of row indices
						const rowIndices = Array.from({ length: this.data[col].length }, (_, i) => i);

						// Sort the row indices based on the values in the specified column (descending)
						rowIndices.sort((a, b) => {
							if (this.data[col][a] > this.data[col][b]) return -1;
							if (this.data[col][a] < this.data[col][b]) return 1;
							return 0;
						});

						// Reorder all columns based on the sorted row indices
						for (const key in this.data) {
							this.data[key] = rowIndices.map(i => this.data[key][i]);
						}

						// Update the selected column
						this.selected_col = col;
					}
				},
				watch: {
					rowCount() {
						this.recomputePagination();
					},
					pageSize() {
						this.recomputePagination();
					},
					current_page() {
						// keep page_list window centered
						this.updatePageList();
					}
				},
				created(){
					this.recomputePagination();

				},

				async mounted() {
                    const gophers = await Gophers();
                    Object.assign(globalThis, gophers);
					var df = ReadJSON(this.data);
					df.Display().ElementID('datatable');

				},
				computed:{
					// Max row count across all columns
					rowCount() {
						let rc = 0;
						for (const c of this.cols || []) {
						const len = (this.data[c] || []).length;
						if (len > rc) rc = len;
						}
						return rc;
					},
					// Indices for the current page
					pageRowIndices() {
						const start = (this.current_page - 1) * this.pageSize;
						const end = Math.min(start + this.pageSize, this.rowCount);
						const n = Math.max(end - start, 0);
						return Array.from({ length: n }, (_, i) => start + i);
					}				
				}

			}).mount('#app')
		</script>
	</html>
